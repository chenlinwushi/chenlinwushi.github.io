<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A1046 Shortest Distance (20) [模拟]</title>
    <url>/2020/02/09/A1046%20Shortest%20Distance%20(20)%20%5B%E6%A8%A1%E6%8B%9F%5D/</url>
    <content><![CDATA[<p>PAT 甲级 A1046 Shortest Distance (20) [模拟]</p>
<a id="more"></a>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><blockquote>
<p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,10^5]), followed by <em>N</em> integer distances <em>D</em>1 <em>D</em>2 ⋯ <em>DN</em>, where <em>Di</em> is the distance between the <em>i</em>-th and the (<em>i</em>+1)-st exits, and <em>DN</em> is between the <em>N</em>-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer <em>M</em>(≤104), with <em>M</em> lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to <em>N</em>. It is guaranteed that the total round trip distance is no more than 107.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1 2 4 14 9</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目大意：</p>
<ul>
<li>求最短路径</li>
</ul>
<p>思路分析：</p>
<ul>
<li><p>以dis[i]表示1号节点按顺时针方向到达<strong>“i号节点顺时针方向的下一个节点”</strong>的距离（1 &lt;= i &lt;= n）</p>
<p>默认dis[0] = 0</p>
<p>注：==若设置为1号节点按顺时针方向到达i号节点的距离==</p>
<p>​        ==则无法保存N号节点到1号节点的距离==</p>
</li>
<li><p>以A[i]表示i号到i+1号顶点的距离</p>
</li>
</ul>
<p>注意点：</p>
<ul>
<li><p>对dis数组和sum进行预处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sum += A[i];  <span class="comment">//累加sum</span></span><br><span class="line">dis[i] = sum;  <span class="comment">//预处理dis数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对每个查询left→right，其结果为dis(left, right)与sum - dis(left,right)中较小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = dis[right - <span class="number">1</span>] - dis[left - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">min</span>(temp, sum - temp));</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], A[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, query, n, left, right;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);  <span class="comment">//输入结点个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">		sum += A[i];  <span class="comment">//sum表示一圈的总距离</span></span><br><span class="line">		dis[i] = sum;  <span class="comment">//对dis数组预处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);  <span class="comment">//输入查询次数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; query; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;left, &amp;right);</span><br><span class="line">		<span class="keyword">if</span>(left &gt; right)</span><br><span class="line">			swap(left, right);</span><br><span class="line">		<span class="keyword">int</span> temp = dis[right - <span class="number">1</span>] - dis[left - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">min</span>(temp, sum - temp));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
        <category>PAT</category>
        <category>A</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>PAT_A</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>A1042 Shuffling Machine (20) [模拟]</title>
    <url>/2020/02/08/A1042%20Shuffling%20Machine%20(20)%20%5B%E6%A8%A1%E6%8B%9F%5D/</url>
    <content><![CDATA[<p>PAT 甲级 A1042 Shuffling Machine (20) [模拟]</p>
<a id="more"></a>



<blockquote>
<p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p>
<p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1, S2, ..., S13, </span><br><span class="line">H1, H2, ..., H13, </span><br><span class="line">C1, C2, ..., C13, </span><br><span class="line">D1, D2, ..., D13, </span><br><span class="line">J1, J2</span><br></pre></td></tr></table></figure>

<p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目大意：</p>
<ul>
<li><p>54张牌，编号为1~54，按初始排列给定花色</p>
<p>S1, S2, …, S13,<br>H1, H2, …, H13,<br>C1, C2, …, C13,<br>D1, D2, …, D13,<br>J1, J2</p>
</li>
<li><p>模拟洗牌机，将牌的位置变为指定位置</p>
<p>如果 i  -th位置的数字是 j <em>，</em>则表示将卡从位置 i 移动到位置 j 。<br>例如，假设我们只有5张牌：S3，H5，C1，D13和J2。<br>给定一个混合顺序{4,2,5,3,1}，结果将是：J2，H5，D13，S3，C1。<br>如果我们要再次重复洗牌，结果将是：C1，H5，S3，J2，D13。</p>
</li>
</ul>
<p>思路分析：</p>
<ul>
<li><p>洗牌操作明确了每个位置上的牌在操作后的位置</p>
<p>使用start[i]存放执行操作前的牌序，</p>
<p>使用end[i]存放执行操作后的牌序</p>
</li>
<li><p>为了将输出用花色表示，使用char数组mp[] = {S, H, C, D, J}建立花色与编号的关系</p>
</li>
</ul>
<p>注意事项：</p>
<ul>
<li><p>如何给牌换位？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">			<span class="built_in">end</span>[next[i]] = start[i];  <span class="comment">//把第i个位置的牌的编号存于位置next[i]</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>start[i]存放牌的初始编号</p>
<p>next[i]存放牌经过一次洗牌后的编号</p>
</li>
<li><p>格式控制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>); </span><br><span class="line">start[i] --;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c%d"</span>, mp[start[i]/<span class="number">13</span>], start[i]%<span class="number">13</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>start[i]取1~13时必须输出0，输出花色时需-1，输出编号再加回来，后续同理</p>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">54</span>;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">5</span>] = &#123;<span class="string">'S'</span>, <span class="string">'H'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'J'</span>&#125;;  <span class="comment">//牌的编号与花色的对应关系:0~4</span></span><br><span class="line"><span class="keyword">int</span> start[N+<span class="number">1</span>], <span class="built_in">end</span>[N+<span class="number">1</span>], next[N+<span class="number">1</span>];  <span class="comment">//next数组存放每个位置上的牌在操作后的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		start[i] = i;  <span class="comment">//初始化牌的编号1~54</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;next[i]);  <span class="comment">//输入每个位置上的牌在操作后的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>; <span class="built_in">step</span> &lt; K; <span class="built_in">step</span> ++) &#123;  <span class="comment">//执行K次操作</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">			<span class="built_in">end</span>[next[i]] = start[i];  <span class="comment">//把第i个位置的牌的编号存于位置next[i]</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">			start[i] = <span class="built_in">end</span>[i];  <span class="comment">//把end数组赋值给start数组以供下次操作使用</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);  <span class="comment">//控制输出格式</span></span><br><span class="line">		start[i] --;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c%d"</span>, mp[start[i]/<span class="number">13</span>], start[i]%<span class="number">13</span>+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
        <category>PAT</category>
        <category>A</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>PAT_A</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>B1002 写出这个数 (20) [字符串处理]</title>
    <url>/2020/02/05/B1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0-20-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>PAT 乙级 B1002 写出这个数 (20) [字符串处理]</p>
<a id="more"></a>



<blockquote>
<p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10^100。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567890987654321123456789</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yi san wu</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路分析：</p>
<ul>
<li><p>使用string接收读入的自然数n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> n;  <span class="comment">//默认初始化，n是一个空字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str[<span class="number">10</span>] = &#123;<span class="string">"ling"</span>,<span class="string">"yi"</span>,<span class="string">"er"</span>, <span class="string">"san"</span>, <span class="string">"si"</span>, <span class="string">"wu"</span>, <span class="string">"liu"</span>, <span class="string">"qi"</span>, <span class="string">"ba"</span>, <span class="string">"jiu"</span>&#125;;  <span class="comment">//将字符数组初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将string中每一位数字累加，保存到sum</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sum = sum + (n[i] - <span class="string">'0'</span>);  <span class="comment">//使用运算符时，自动将操作数转换为相同的类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将sum转化为string类型的num</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> num = to_string(sum);  <span class="comment">//调用to_string函数将整型sum转化为string类型的num</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>依次对num中每一位输出对应的汉语拼音</p>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str[<span class="number">10</span>] = &#123;<span class="string">"ling"</span>,<span class="string">"yi"</span>,<span class="string">"er"</span>, <span class="string">"san"</span>, <span class="string">"si"</span>, <span class="string">"wu"</span>, <span class="string">"liu"</span>, <span class="string">"qi"</span>, <span class="string">"ba"</span>, <span class="string">"jiu"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length(); i ++)</span><br><span class="line">        sum = sum + (n[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">string</span> num = to_string(sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[num[i] - <span class="string">'0'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
        <category>PAT</category>
        <category>B</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>PAT_B</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>A1002  A+B for Polynomials (25) [模拟]</title>
    <url>/2020/02/04/A1002-A-B-for-Polynomials-25-%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>PAT 甲级 A1002  A+B for Polynomials (25) [模拟]</p>
<a id="more"></a>



<blockquote>
<p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K N1 aN1 N2 aN2 … NK aNK</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>Ni</em> and <em>aNi</em> (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>NK</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 1.5 1 2.9 0 3.2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目大意：</p>
<ul>
<li>给出两行，每行表示一个多项式，第一个数表示非零项的项数，后面相邻的每两个数表示一项，分别为该项的幂次和系数。</li>
<li>求出多项式的和以相同格式输出</li>
</ul>
<p>思路分析：</p>
<ul>
<li><p>设立c数组，长度为指数的最大值，c[i] = j表示指数i的系数为j，接收a和b输入的同时将对应指数 </p>
<p>的系数加入到c中，累计c中所有非零系数的个数，然后从后往前输出所有系数不为0的指数和系数</p>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> c[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> m, n, t;</span><br><span class="line">	<span class="keyword">float</span> num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%f"</span>, &amp;t, &amp;num);</span><br><span class="line">		c[t] += num;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%f"</span>, &amp;t, &amp;num);</span><br><span class="line">		c[t] += num;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c[i] != <span class="number">0</span>) cnt++;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c[i] != <span class="number">0.0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, i, c[i]);</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
        <category>PAT</category>
        <category>A</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>PAT_A</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>B1001 害死人不偿命的(3n+1)猜想 (15) [模拟]</title>
    <url>/2020/02/04/B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3-(15)-%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>PAT 乙级 B1001 害死人不偿命的(3n+1)猜想 (15) [模拟] </p>
<a id="more"></a>



<blockquote>
<p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>=1？</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路分析：</p>
<ul>
<li>使用count计数器从0开始统计需要的步数</li>
<li>读入n，使用while循环判断n是否为1</li>
<li>每判断一次，计数器加一</li>
<li>输出count</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">           n = <span class="number">3</span> * n + <span class="number">1</span>;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
        <category>PAT</category>
        <category>B</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>PAT_B</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
